<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
<link rel="icon" type="image/png" href="https://i.ibb.co/XfC4BDXk/Screenshot-3.png">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Random Image</title>
  <style>
    :root { --fade-ms: 500ms; --ui-h: 0vh; }
    html, body { height: 100%; overflow: hidden; }
    body{
      margin:0; background:#000; color:#fff; font-family: Arial, sans-serif;
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
    }

    /* אזור עליון – עוגן לשכבות העל */
    /* עוגן לאזור העליון – דינמי ויציב במובייל */
#topWrap{
  position: relative;
  height: calc(100dvh - var(--ui-h));
  width:100%;
  display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
  box-sizing:border-box; padding-top:6px;
}
@supports not (height: 100dvh) {
  #topWrap{ height: calc(100vh - var(--ui-h)); }
}
/* אזורי טאץ' לקצוות המסך (מופעלים רק במובייל/טאבלט) */
.tapZone{
  display:none;
  position:fixed;
  top:0;
  bottom:var(--ui-h);   /* לא חוסם את ה-controls */
  width:33vw;           /* אפשר לשנות ל-30–40vw לפי הטעם */
  z-index:5;            /* נמוך מה-controls (z=10) כדי שהכפתורים יישארו קליקים */
  -webkit-tap-highlight-color: transparent;
  background: transparent;
}
.tapLeft{  left:0; }
.tapRight{ right:0; }

/* הפעלה רק במובייל / מסכי טאץ' */
@media (max-width: 900px), (pointer: coarse){
  .tapZone{ display:block; }
}

/* פידבק קל בלחיצה (אופציונלי) */
.tapZone:active{ background: rgba(255,255,255,0.03); }


    /* טקסט השאילתה – שכבת-על, לא מזיזה את התמונה */
    #queryText{
      position:absolute;
      top:1vh;
      left:50%;
      transform:translateX(-50%);
      width:auto;
      max-width:94vw;
      padding:0 12px;
      pointer-events:none; z-index:2;
      font-size:18px; line-height:1.2;
      display:none; opacity:0; transition:opacity var(--fade-ms) ease-in-out;
      text-align:center; word-break:break-word; direction:rtl;
      text-shadow:0 1px 2px rgba(0,0,0,.6);
    }
    #queryText.visible{ opacity:1; }

    /* אינפוט הקלט – באותו מקום בדיוק */
    #customInput{
      position:absolute;
      top:1vh;
      left:50%;
      transform:translateX(-50%);
      width:min(720px, 94vw); max-width:94vw; box-sizing:border-box;
      padding:10px 12px;
      border-radius:10px; border:1px solid rgba(255,255,255,.25);
      background:rgba(0,0,0,.45); color:#fff;
      font-size:18px; line-height:1.2;
      outline:none; z-index:4;
      display:none;
    }
    #customInput.show{ display:block; }

    #imageWrap{
      flex:1 1 auto; width:100%;
      display:flex; align-items:center; justify-content:center;
    }
   #mainImg{
  width:auto; height:auto;                /* לא "מתיחה" קשיחה */
  max-width:94vw;
  max-height: calc(100dvh - var(--ui-h) - 12px);  /* תמיד נשארת מעל ה-controls */
  border-radius:8px;
  opacity:0;
  transition: opacity var(--fade-ms) ease-in-out;
  will-change: opacity;
  user-select:none; pointer-events:none; background:transparent;
  display:block;
}
@supports not (height: 100dvh) {
  #mainImg{ max-height: calc(100vh - var(--ui-h) - 12px); }
}

/* דסקטופ עדין כמו שהיה */
@media (min-width: 901px) and (pointer: fine){
  #mainImg{ max-width:90vw; max-height:90vh; }
}

    /* UI תחתון למובייל בלבד */
.controls{
  display:none; position:fixed; left:0; right:0; bottom:0;
  height:30vh; z-index:10;               /* מעל הכל */
  padding-bottom: env(safe-area-inset-bottom); /* רווח ל-notch */
}
.controls-inner{
  height:100%; width:100%; max-width:560px; margin:0 auto;
  display:flex; flex-direction:column; justify-content:center; gap:10px;
  padding:10px 12px; box-sizing:border-box;
  background: rgba(255,255,255,0.06);
  border-top: 1px solid rgba(255,255,255,0.12);
  backdrop-filter: blur(10px);
}
@media (max-width: 900px), (pointer: coarse){
  :root{ --ui-h: 28vh; }   /* טיפונת פחות כדי לתת עוד מקום לתמונה */
  .controls{ display:block; }
  .controls-inner{ max-width: 100%; }
  .controls button{ font-size:16px; padding:14px 16px; }
}

    .row{ display:flex; gap:10px; justify-content:center; width:100%; }
    .row.nav button{ flex:1; min-width:140px; }
    .row.modes button{ flex:1; min-width:90px; }
    .row .full{ flex:1; }
    .controls button{
      appearance:none; cursor:pointer; border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.08); color:#fff; padding:10px 12px; border-radius:10px;
      font-size:14px; line-height:1; transition: transform 120ms ease, background 120ms, border-color 120ms;
    }
    .controls button:active{ transform:scale(0.98); }
    .controls button.active{ background:rgba(255,255,255,0.18); border-color:rgba(255,255,255,0.35); }

    /* DEBUG overlay (מוסתר כברירת־מחדל, נפתח ב-L) */
    #debug{
      position:fixed; left:8px; bottom:8px; width:min(46ch, 90vw);
      max-height:40vh; overflow:auto; font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, monospace;
      background:rgba(0,0,0,0.55); color:#0f0; border:1px solid rgba(0,255,0,0.25);
      padding:6px 8px; border-radius:8px; z-index:3; white-space:pre-wrap;
    }
    #debug.hidden{ display:none; }
  </style>
</head>
<body>
  <div id="topWrap">
    <div id="queryText"></div>
    <input id="customInput" type="text" placeholder="הקלד/י ביטוי… (Enter לאישור, Esc לביטול)" />
    <div id="imageWrap">
      <img id="mainImg" alt="">
    </div>
  </div>
<div id="tapLeft"  class="tapZone tapLeft"  aria-hidden="true"></div>
<div id="tapRight" class="tapZone tapRight" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <div class="controls-inner">
      <div class="row nav">
        <button id="btnPrev">◀</button>
        <button id="btnNext">▶</button>
      </div>
      <div class="row modes">
        <button id="btnNumber" class="active">Num</button>
        <button id="btnWord">Word</button>
      </div>
      <div class="row">
        <button id="btnToggleSearch" class="full">Show search</button>
      </div>
    </div>
  </div>

  <pre id="debug" class="hidden"></pre>

  <script>

/* ===== Random Image (Picsum) + History + Logs — minimal ===== */

// ----- Debug overlay -----
const dbg = document.getElementById("debug");
let debugVisible = !!dbg && !dbg.classList.contains("hidden");
const updateDebugVis = () => { if (dbg) dbg.classList.toggle("hidden", !debugVisible); };
const dlog = (...a) => {
  const line = a.join(" ");
  if (dbg) { dbg.textContent += line + "\n"; dbg.scrollTop = dbg.scrollHeight; }
  else console.log(line);
};
window.onerror = (m, s, l, c) => dlog("window.onerror:", m, "@", s+":"+l+":"+c);
window.onunhandledrejection = (e) => dlog("unhandledrejection:", (e?.reason?.stack || e?.reason?.message) || e);
dlog("Boot…");

// ----- DOM -----
const imgEl  = document.getElementById("mainImg");
const btnPrev = document.getElementById("btnPrev");
const btnNext = document.getElementById("btnNext");

// ----- Config: fixed ranges (not tied to screen) -----
const SIZE_CONF = {
  MIN_W: 400,   // מינימום רוחב ל־request
  MAX_W: 1600,  // מקסימום רוחב ל־request
  MIN_H: 300,   // מינימום גובה ל־request
  MAX_H: 1200,  // מקסימום גובה ל־request
  DPR_MAX: 2,   // להכפיל לפי devicePixelRatio עד תקרה זו
  // אם לא רוצים שום הגבלת יחס, שימו ASPECT_MIN=0, ASPECT_MAX=Infinity
  ASPECT_MIN: 0.5,  // 0.5 ~ גבוה יחסית
  ASPECT_MAX: 2.0   // 2.0 ~ רחב יחסית
};

const randIntRange = (min, max) => Math.round(min + Math.random() * (max - min));

// מייצר רוחב/גובה רנדומליים אמיתיים, ללא תלות במסך
function pickRandomSize() {
  const { MIN_W, MAX_W, MIN_H, MAX_H, DPR_MAX, ASPECT_MIN, ASPECT_MAX } = SIZE_CONF;

  const baseW = randIntRange(MIN_W, MAX_W);
  const baseH = randIntRange(MIN_H, MAX_H);

  const dpr = Math.min(window.devicePixelRatio || 1, DPR_MAX);
  let w = Math.round(baseW * dpr);
  let h = Math.round(baseH * dpr);

  // תקרה אחרי DPR
  w = Math.min(w, Math.round(MAX_W * DPR_MAX));
  h = Math.min(h, Math.round(MAX_H * DPR_MAX));

  // שמירת יחס "הגיוני" (בטל ע"י 0/Infinity אם לא רוצים)
  if (ASPECT_MIN > 0 || ASPECT_MAX < Infinity) {
    let aspect = w / h;
    if (aspect < ASPECT_MIN) {
      h = Math.max(Math.round(w / ASPECT_MIN), MIN_H);
    } else if (aspect > ASPECT_MAX) {
      h = Math.max(Math.round(w / ASPECT_MAX), MIN_H);
    }
  }

  const aspect = (w / h);
  dlog(`[SIZE] base=${baseW}x${baseH}, dpr=${dpr.toFixed(2)} -> req=${w}x${h}, aspect=${aspect.toFixed(3)}`);
  return { w, h };
}

// בונה URL ל-Picsum עם cache-bust
function buildPicsumUrl() {
  const { w, h } = pickRandomSize();
  const cacheBust = Date.now() + "_" + Math.floor(Math.random() * 1e9);
  const url = `https://picsum.photos/${w}/${h}?r=${cacheBust}`;
  dlog(`[PICSUM] url: ${url}`);
  return { url, w, h };
}

// ----- State / history -----
let history = [];    // [{url, w, h}]
let index = -1;
let isFetching = false;
let fetchToken = 0;
let viewToken  = 0;

// טעינה עם פרילוד וחילוף עדין (מבוסס מחלקת CSS "visible")
function transitionTo(url, meta = {}) {
  const myView = ++viewToken;

  const pre = new Image();
  pre.decoding = "async";

  pre.onload = () => {
    if (myView !== viewToken) return; // הוזן כבר משהו חדש בינתיים
    imgEl.classList.remove("visible"); // התחלת fade-out
    const swap = () => {
      imgEl.removeEventListener("transitionend", swap);
      if (myView !== viewToken) return;
      imgEl.src = pre.src;

      // לתת פריים אחד ל-layout ואז להדליק fade-in
      requestAnimationFrame(() => requestAnimationFrame(() => {
        if (myView !== viewToken) return;
        imgEl.classList.add("visible");

        // לוג של מידות טבעיות + תצוגה בפועל
        const natural = `${pre.naturalWidth}x${pre.naturalHeight}`;
        const shown   = `${imgEl.clientWidth}x${imgEl.clientHeight}`;
        dlog(`[IMG] natural=${natural}, shown=${shown}`);
      }));
    };

    // אם זו טעינה ראשונה ואין טרנזישן, נחליף מיד
    if (!imgEl.getAttribute("src")) {
      imgEl.src = pre.src;
      requestAnimationFrame(() => imgEl.classList.add("visible"));
      const natural = `${pre.naturalWidth}x${pre.naturalHeight}`;
      const shown   = `${imgEl.clientWidth}x${imgEl.clientHeight}`;
      dlog(`[IMG] (first) natural=${natural}, shown=${shown}`);
    } else {
      // חילוף אחרי מעבר
      imgEl.addEventListener("transitionend", swap, { once: true });
      // סתם ביטוח אם transitionend לא יורה
      setTimeout(swap, 520);
    }
  };

  pre.onerror = () => {
    dlog("[IMG] preload error — trying next…");
    // נסה ישר תמונה חדשה
    isFetching = false;
    fetchAndAppendNewImage();
  };

  pre.src = url;
}

// מביא תמונה חדשה ודוחף להיסטוריה
async function fetchAndAppendNewImage() {
  if (isFetching) { dlog("Skip: already fetching"); return; }
  isFetching = true; const myToken = ++fetchToken;

  try {
    const { url, w, h } = buildPicsumUrl();
    if (myToken !== fetchToken) return;

    // אם חזרת אחורה ואז קדימה – קוטם את הזנב
    if (index < history.length - 1) history.length = index + 1;

    history.push({ url, w, h });
    index = history.length - 1;

    transitionTo(url, { w, h });
  } catch (e) {
    dlog("Fatal fetchAndAppend:", e?.message || e);
  } finally {
    isFetching = false;
  }
}

// ניווט בהיסטוריה
function navigate(delta) {
  if (!history.length) return;
  const target = Math.min(Math.max(index + delta, 0), history.length - 1);
  if (target === index) {
    if (delta > 0) fetchAndAppendNewImage(); // בקשת קדימה מעבר לסוף => תביא חדש
    return;
  }
  index = target;
  const { url } = history[index];
  dlog(`Navigate to #${index}`);
  transitionTo(url);
}

// ----- Controls (אם קיימים) -----
btnPrev && btnPrev.addEventListener("click", () => navigate(-1));
btnNext && btnNext.addEventListener("click", () => navigate(+1));

// ----- Keyboard -----
document.addEventListener("keydown", (ev) => {
  if (ev.repeat) return;
  const k = ev.key.toLowerCase();
  if (k === " ")      { ev.preventDefault(); fetchAndAppendNewImage(); }
  else if (k === "arrowleft")  navigate(-1);
  else if (k === "arrowright") navigate(+1);
  else if (k === "l")  { debugVisible = !debugVisible; updateDebugVis(); }
});
document.getElementById('tapLeft')?.addEventListener('click', () => navigate(-1));
document.getElementById('tapRight')?.addEventListener('click', () => navigate(+1));

// ----- Init -----
updateDebugVis();   // אם יש <pre id="debug">
fetchAndAppendNewImage();

  </script>
</body>
</html>










