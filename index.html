<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Random Image — Clean</title>
  <style>
    :root { --fade-ms: 500ms; --ui-h: 0vh; }

    html, body { height: 100%; overflow: hidden; }
    body{
      margin:0; background:#000; color:#fff; font-family: Arial, sans-serif;
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
    }

    /* עוגן אזור תצוגה */
    #topWrap{
      position: relative;
      height: calc(100dvh - var(--ui-h));
      width:100%;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      box-sizing:border-box; padding:6px 0;
    }
    @supports not (height: 100dvh) {
      #topWrap{ height: calc(100vh - var(--ui-h)); }
    }

    #imageWrap{
      flex:1 1 auto; width:100%;
      display:flex; align-items:center; justify-content:center;
    }
    /* התמונה לעולם לא נמתחת מעבר למסך, ולא ממלאת בכוח */
    #mainImg{
      width:auto; height:auto;
      max-width:94vw;
      max-height: calc(100dvh - 12px);
      border-radius:8px;
      opacity:0;
      transition: opacity var(--fade-ms) ease-in-out;
      will-change: opacity;
      user-select:none; pointer-events:none; background:transparent;
      display:block;
    }
    @supports not (height: 100dvh) {
      #mainImg{ max-height: calc(100vh - 12px); }
    }
    @media (min-width: 901px) and (pointer: fine){
      #mainImg{ max-width:90vw; max-height:90vh; }
    }
    #mainImg.visible{ opacity:1; }

    /* אזורי טאץ' לקצוות המסך (למובייל) */
    .tapZone{
      display:none;
      position:fixed;
      top:0; bottom:0;
      width:33vw;
      z-index:5;
      -webkit-tap-highlight-color: transparent;
      background: transparent;
      touch-action: manipulation;
      user-select:none;
    }
    .tapLeft{  left:0; }
    .tapRight{ right:0; }
    @media (max-width: 900px), (pointer: coarse){
      .tapZone{ display:block; }
    }
    .tapZone:active{ background: rgba(255,255,255,0.03); }

    /* הסתרה מוחלטת של ה־UI הישן אם במקרה נשאר ב־DOM */
    .controls{ display:none !important; }

    /* DEBUG overlay (נפתח ב־L) */
    #debug{
      position:fixed; left:8px; bottom:8px; width:min(46ch, 90vw);
      max-height:40vh; overflow:auto; font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, monospace;
      background:rgba(0,0,0,0.55); color:#0f0; border:1px solid rgba(0,255,0,0.25);
      padding:6px 8px; border-radius:8px; z-index:6; white-space:pre-wrap;
    }
    #debug.hidden{ display:none; }
  </style>
</head>
<body>
  <div id="topWrap">
    <div id="imageWrap">
      <img id="mainImg" alt="">
    </div>
  </div>

  <!-- אזורי טאץ' -->
  <div id="tapLeft"  class="tapZone tapLeft"  aria-hidden="true"></div>
  <div id="tapRight" class="tapZone tapRight" aria-hidden="true"></div>

  <pre id="debug" class="hidden"></pre>

  <script>
  /* ===== Random Image (Picsum) — Clean ===== */

  // --- Debug overlay ---
  const dbg = document.getElementById("debug");
  let debugVisible = false;
  const updateDebugVis = () => { if (dbg) dbg.classList.toggle("hidden", !debugVisible); };
  const dlog = (...a) => {
    const line = a.join(" ");
    if (dbg) { dbg.textContent += line + "\n"; dbg.scrollTop = dbg.scrollHeight; }
    else console.log(line);
  };
  window.onerror = (m, s, l, c) => dlog("window.onerror:", m, "@", s+":"+l+":"+c);
  window.onunhandledrejection = (e) => dlog("unhandledrejection:", (e?.reason?.stack || e?.reason?.message) || e);
  dlog("Boot…");

  // --- DOM ---
  const imgEl  = document.getElementById("mainImg");

  // --- Config: טווחי גודל קשיחים ולא תלויי מסך ---
  const SIZE_CONF = {
    MIN_W: 500,
    MAX_W: 1400,
    MIN_H: 350,
    MAX_H: 1100,
    DPR_MAX: 2,           // תקרת DPR
    ASPECT_MIN: 0,        // בלי הגבלת יחס — אם תרצה, שים 0.5
    ASPECT_MAX: Infinity  // אם תרצה, שים 2.0
  };

  const randIntRange = (min, max) => Math.round(min + Math.random() * (max - min));

  // מייצר רוחב/גובה רנדומליים אמיתיים
  function pickRandomSize() {
    const { MIN_W, MAX_W, MIN_H, MAX_H, DPR_MAX, ASPECT_MIN, ASPECT_MAX } = SIZE_CONF;

    const baseW = randIntRange(MIN_W, MAX_W);
    const baseH = randIntRange(MIN_H, MAX_H);

    const dpr = Math.min(window.devicePixelRatio || 1, DPR_MAX);
    let w = Math.round(baseW * dpr);
    let h = Math.round(baseH * dpr);

    // תקרה אחרי DPR
    const W_MAX = Math.round(MAX_W * DPR_MAX);
    const H_MAX = Math.round(MAX_H * DPR_MAX);
    w = Math.min(w, W_MAX);
    h = Math.min(h, H_MAX);

    // שמירת יחס (אם מופעל)
    if (ASPECT_MIN > 0 || ASPECT_MAX < Infinity) {
      let aspect = w / h;
      if (aspect < ASPECT_MIN) {
        h = Math.max(Math.round(w / ASPECT_MIN), MIN_H);
      } else if (aspect > ASPECT_MAX) {
        h = Math.max(Math.round(w / ASPECT_MAX), MIN_H);
      }
      // clamp נוסף אחרי התאמת יחס
      w = Math.min(Math.max(w, MIN_W), W_MAX);
      h = Math.min(Math.max(h, MIN_H), H_MAX);
    }

    const aspect = (w / h);
    dlog(`[SIZE] base=${baseW}x${baseH}, dpr=${dpr.toFixed(2)} -> req=${w}x${h}, aspect=${aspect.toFixed(3)}`);
    return { w, h };
  }

  // בונה URL ל-Picsum עם cache-bust
  function buildPicsumUrl() {
    const { w, h } = pickRandomSize();
    const cacheBust = Date.now() + "_" + Math.floor(Math.random() * 1e9);
    const url = `https://picsum.photos/${w}/${h}?r=${cacheBust}`;
    dlog(`[PICSUM] url: ${url}`);
    return { url, w, h };
  }

  // --- State / history ---
  let history = [];    // [{url, w, h}]
  let index = -1;
  let isFetching = false;
  let fetchToken = 0;
  let viewToken  = 0;

  // טעינה עם פרילוד + fade
  function transitionTo(url) {
    const myView = ++viewToken;
    const pre = new Image();
    pre.decoding = "async";

    pre.onload = () => {
      if (myView !== viewToken) return;
      const swap = () => {
        imgEl.removeEventListener("transitionend", swap);
        if (myView !== viewToken) return;
        imgEl.src = pre.src;
        requestAnimationFrame(() => requestAnimationFrame(() => {
          if (myView !== viewToken) return;
          imgEl.classList.add("visible");
          dlog(`[IMG] natural=${pre.naturalWidth}x${pre.naturalHeight}, shown=${imgEl.clientWidth}x${imgEl.clientHeight}`);
        }));
      };

      // טעינה ראשונה – בלי fade-out
      if (!imgEl.getAttribute("src")) {
        imgEl.src = pre.src;
        requestAnimationFrame(() => imgEl.classList.add("visible"));
        dlog(`[IMG] (first) natural=${pre.naturalWidth}x${pre.naturalHeight}, shown=${imgEl.clientWidth}x${imgEl.clientHeight}`);
      } else {
        imgEl.classList.remove("visible");
        imgEl.addEventListener("transitionend", swap, { once: true });
        setTimeout(swap, 520);
      }
    };

    pre.onerror = () => {
      dlog("[IMG] preload error — will try next");
      isFetching = false;
      fetchAndAppendNewImage({ retryFromError: true });
    };

    pre.src = url;
  }

  // מביא תמונה חדשה (עם תקרת ניסיונות + fallback)
  let retryCount = 0;
  async function fetchAndAppendNewImage(opts = {}) {
    if (isFetching && !opts.retryFromError) { dlog("Skip: already fetching"); return; }
    isFetching = true; const myToken = ++fetchToken;

    try {
      const { url, w, h } = buildPicsumUrl();
      if (myToken !== fetchToken) return;

      // קוטם זנב אם חזרנו אחורה
      if (index < history.length - 1) history.length = index + 1;

      history.push({ url, w, h });
      index = history.length - 1;

      transitionTo(url);
      retryCount = 0; // הצליח להגיע לשלב הפרילוד
    } catch (e) {
      dlog("Fatal fetchAndAppend:", e?.message || e);
      if (retryCount < 3) {
        retryCount++;
        dlog(`Retry #${retryCount}…`);
        fetchAndAppendNewImage({ retryFromError: true });
      } else {
        const fallback = "https://placekitten.com/800/600";
        dlog(`[FALLBACK] ${fallback}`);
        history.push({ url: fallback, w: 800, h: 600 });
        index = history.length - 1;
        transitionTo(fallback);
        retryCount = 0;
      }
    } finally {
      isFetching = false;
    }
  }

  // ניווט בהיסטוריה
  function navigate(delta) {
    if (!history.length) return;
    const target = Math.min(Math.max(index + delta, 0), history.length - 1);
    if (target === index) {
      if (delta > 0) fetchAndAppendNewImage(); // קדימה מעבר לסוף => תביא חדש
      return;
    }
    index = target;
    const { url } = history[index];
    dlog(`Navigate to #${index}`);
    transitionTo(url);
  }

  // --- Touch zones (מובייל) ---
  document.getElementById('tapLeft')?.addEventListener('click', () => navigate(-1));
  document.getElementById('tapRight')?.addEventListener('click', () => navigate(+1));

  // --- Keyboard ---
  document.addEventListener("keydown", (ev) => {
    if (ev.repeat) return;
    const k = ev.key.toLowerCase();
    if (k === " ")      { ev.preventDefault(); fetchAndAppendNewImage(); }
    else if (k === "arrowleft")  navigate(-1);
    else if (k === "arrowright") navigate(+1);
    else if (k === "l")  { debugVisible = !debugVisible; updateDebugVis(); }
  });

  // --- Init ---
  updateDebugVis();   // פתח לוגים עם L
  fetchAndAppendNewImage();
  </script>
</body>
</html>
